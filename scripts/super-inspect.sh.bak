#!/bin/bash

# slideshows modsub2 images to facilitate human verification of proper light subtraction

source common.sh

# print usage message if number of parameters is incorrect
[ $# -ge 1 ] || abort "usage: $0 <directory/containing/galaxy/directories>"

containing_dir="$(strip_trailing_slash "$1")"
if [ -z "$2" ]; then
	file_filter='modsub2.fits'
else
	file_filter="$2"
fi

# start DS9 if not running
if ! ds9_xpa_running; then
	echo_debug "starting DS9..."
	ds9 &

	# wait for DS9 to start
	while ! ds9_xpa_running; do sleep 1; done
fi

galaxy_count=0
for galaxy_dir in "$containing_dir"/*/; do
	galaxy_dirs[$galaxy_count]="$galaxy_dir"
	((galaxy_count++))
done

galaxy_index=0
frame_count=0

for_each_frame() {
	xpaset -p ds9 frame first
	frames_remaining=$frame_count
	while [ frames_remaining -gt 0 ]; do
		xpaset -p ds9 $@
		xpaset -p ds9 frame next
		((frames_remaining--))
	done
}

parse_command() {
	case "$1" in
		h,help)
			echo "command list:"
			echo "    p[rev]    : view previous galaxy"
			echo "    n[ext]    : view next galaxy"
			echo "    f[ind]    : find galaxy by name"
			echo "    m[odsub2] : load modsub2 images"
			echo "    o[riginal]: load original images"
			echo "    r[egion]  : load regions for each image"
			echo "    c[lear]   : clear all regions"
			echo "    z[scale]  : use linear zscale scaling"
			echo "    l[og]     : use log zmax scaling"
			;;
		p,prev)
			parse_command 'decrement'
			parse_command 'modsub2'
			;;
		n,next)
			parse_command 'increment'
			parse_command 'modsub2'
			;;
		f,find)
			for index in seq 0 $((galaxy_count - 1)); do
				if grep -q "$2" <<< "$galaxy_dirs[$index]"; then
					parse_command "seek $index"
					return
				fi
				echo "    not found"
			done
			;;
		m,modsub2)
			parse_command 'reset'
			for image in "$galaxy_dirs[$galaxy_index]"/*modsub2.fits; do
				parse_command "load \"$image\" \"$(sed -e 's/_modsub2\.fits$/_mod2.reg/g' <<< "$image")\""
			done
			parse_command 'zscale'
			;;
		o,original)
			parse_command 'reset'
			for image in "$galaxy_dirs[$galaxy_index]"/VCC????_?.fits; do
				parse_command "load \"$image\" \"$(sed -e 's/\.fits$/_mod2.reg/g' <<< "$image")\""
			done
			parse_command 'log'
			;;
		r,region)
			xpaset -p ds9 frame first
			for region in regions; do
				[ -f "$region" ] && xpaset -p ds9 regions load "$region"
				xpaset -p ds9 frame next
			done
			;;
		c,clear)
			for_each_frame regions delete all
			;;
		z,zscale)
			for_each_frame scale linear
			for_each_frame scale mode zscale
			;;
		l,log)
			for_each_frame scale log
			for_each_frame scale mode zmax
			;;
		i,increment)
			parse_command seek $((galaxy_index + 1))
			;;
		d,decrement)
			parse_command seek $((galaxy_index - 1))
			;;
		s,seek)
			if ! [ "$2" -eq "$2" ] 2>/dev/null; then
				echo "parameter must be an integer"
				return
			fi

			galaxy_index=$2

			if [ $galaxy_index -lt 0 ]; then
				echo "cannot go before the first galaxy"
				galaxy_index=0
			elif [ $galaxy_index -ge $galaxy_count ]; then
				echo "cannot go past the last galaxy"
				galaxy_index=$((galaxy_count - 1))
			fi
			;;
		reset)
			xpaset -p ds9 frame delete all
			frame_count=0
			regions=
			;;
		load)
			echo "    loading $2"
			xpaset -p ds9 frame new
			xpaset -p ds9 fits "$2"
			regions[$frame_count]="$3"
			((frame_count++))
			;;
		*)
			echo "unknown command: $1"
			parse_command 'help'
			;;
	esac
}

skip_to_dir=''
for galaxy_dir in "$containing_dir"/*/; do
	if ! grep -q "$skip_to_dir" <<< "$galaxy_dir"; then
		echo "    skipping $galaxy_dir"
		continue
	else
		skip_to_dir=''
	fi
	
	input="prompt"
	while :; do

		read -p "enter command (h for help): " -r input
	done
done

# loop over all modsub2 images
for image in $(find "$containing_dir" | grep "$file_filter" | sort); do
	# if image does not match search string
	if ! grep -q "$search_for" <<< "$image"; then
		echo "    skipping $image: does not match search string $search_for"
		continue
	fi

	assert_successful ./inspect.sh "$image"
	assert_successful ./inspect-circles.sh "$image"

	# press Enter to view next image
	echo "current: $image"
	read -p "enter search string, or press Enter for next: " search_for
done
